yarn create react-app <프로젝트 이름>

## jsx란 ?

- jsx는 자바스크립트의 확장 문법이며 XML과 매우 비슷하게 생겼습니다. 이런 형식으로 작성한 코드는 브라우저에서 실행되기 전에 코드가 번들링되는 과정에서 바벨을 사용하여 일반 자바스크립트 형태의 코드로 변환됩니다.

## jsx의 장점

1. 보기 쉽고 익숙하다

- 보기만 해도 jsx를 사용하는 편이 더 가독성이 높고 작성하기 쉽다.
- 이러한 이유 때문에 jsx를 사용하는 주된 이유 입니다.

2. 더욱 높은 활용도

- jsx에서는 우리가 알고 있는 div나 span 같은 HTML 태그를 사용할 수 있을 뿐만 아니라 컴포넌트도 jsx 안에서 작성할 수 있습니다.

## jsx 문법

1. 컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 합니다.

```jsx
// 부모요소로 감싸지 않은 경우 오류발생
function App() {
  return (
    <h1>리액트 안녕</h1>
    <h1>잘 작동하니?</h1>
  );
}

// 부모 요소로 감싸면 작동 합니다.
function App() {
  return (
    <div>
      <h1>리액트 안녕</h1>
      <h1>잘 작동하니?</h1>
    </div>
  );
}

// <div> 를 사용하고 싶지 않은 경우 Fragment 기능을 사용합니다.
function App() {
  return (
    <Fragment>
      <h1>리액트 안녕</h1>
      <h1>잘 작동하니?</h1>
    </Fragment>
  );
}
// Fragment는 생략가능합니다.
function App() {
  return (
    <>
      <h1>리액트 안녕</h1>
      <h1>잘 작동하니?</h1>
    </>
  );
}
```

2. if문 대신 조건부 연산자를 사용합니다.

```jsx
function App() {
  const name = undefined;
  return (
    <div>
      {name === "리액트" ? (
        <h1>리액트 입니다.</h1>
      ) : (
        <h2>리액트가 아닙니다.</h2>
      )}
    </div>
  );
}
```

3. undefined만 반환하여 렌더링하는 상황을 만들면 안됩니다.

```jsx
// 오류 발생
function App() {
  const name = undefined;
  return name;
}

// 오류가 발생하지 않습니다.
function App() {
  const name = undefined;
  return <div>{name || "리액트"}</div>;
}
```

## 인라인 스타일링

```jsx
function App() {
  const name = "리액트";
  return (
    <div
      style={{
        // -문자가 포함되는 이름은 카멜 표기법으로 작성합니다.
        backgroundColor: "black",
        color: "aqua",
        fontSize: "48px",
      }}
    >
      {name}
    </div>
  );
}
```

## 꼭 닫아야 하는 태그

- input 같은 경우에는 태그를 닫지않은 상태에도 정상 작동합니다. 하지만 jsx에서는 코드를 닫지 않으면 오류가 발생하므로 꼭 닫아주어야 합니다 `<input />` 같은 태그를 self-closing 태그라고 부릅니다.

## 주석 처리

- jsx 내부에서 주석 작성할때는 {/_ '''' _/} 형식으로 작성합니다.

```jsx
function App() {
  const name = "리액트";
  // 이 경우에는 // 를 사용해도 가능합니다.
  return (
    // 이 경우에는 // 를 사용해도 가능합니다.
    <div className="react">
      {/* 여기서는 //가 사용 불가능합니다. */}
      {name}
    </div>
  );
}
```

# 3장

## 클래스형 컴포넌트

- 함수형 컴포넌트와 달리 state와 라이프사키을 API를 사용할 수 있습니다.
- 리액트 v16.8 이후로 Hooks라는 기능 도입 후 함수형에서도 조금 다른 방식으로 사용 가능할 수 있습니다.

## 함수형 컴포넌트

- 클래스형 컴포넌트보다 선언하기 편합니다.
- 메모리 자원도 클래스형 컴포넌트보다 덜 사용합니다.
- 프로젝트를 완성하여 빌드한 후 배포할 때도 함수형 컴포넌트를 사용하는 것이 결과물의 파일 크기가 더 작습니다.

> Reactjs Code Snippet 사용
>
> Vs Code에서 Reactjs Code Snippet 을 설치하고 rsc를 입력하고 엔터를 누르면 함수형 컴포넌트를 생성 rcc를 입력하면 클래스형 컴포넌트를 생성합니다.

## 비구조화 할당 문법을 통해 props 내부 값 추출하기

- 구조 분해 문법이라고도 부릅니다.

```jsx
const MyComponent = (props) => {
  const { name, children } = props;
  return <div>안녕하세요 내 이름은 {name}</div>;
};
```

- 함수의 파라미터에서도 사용가능 합니다.

```jsx
const MyComponent = ({ name, children }) => {
  return <div>안녕하세요 내 이름은 {name}</div>;
};
```

## propTypes를 통한 props 검증

- 100page 참고

## state

- state는 컴포넌트 내부에서 바뀔 수 있는 값을 의미합니다.
- props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값이며, 컴포넌트 자신은 해당 props를 읽기 전용으로만 사용 할 수 있습니다. props를 바꾸려면 부모 컴포넌트에서 바꾸어 주어야 합니다.

### 리액트에는 두 가지 종류의 state가 있습니다

1.  클래스형 컴포넌트가 지니고 있는 state

```jsx
class Counter extends Component {
  constructor(props) {
    super(props);

    this.state = {
      number: 0,
    };
  }
  render() {
    const { number } = this.state;
    return (
      <div>
        <h1>{number}</h1>
        <button
          onClick={() => {
            this.setState({ number: number + 1 });
          }}
        >
          +1
        </button>
      </div>
    );
  }
}
```

2.  함수형 컴포넌트에서 useState라는 함수를 통해 사용하는 state

```jsx
import React, { useState } from "react";

const Say = () => {
  const [message, setMessage] = useState("");
  const onClickEnter = () => setMessage("HI");
  const onClickLeave = () => setMessage("Bye");

  return (
    <div>
      <button onClick={onClickEnter}>enter</button>
      <button onClick={onClickLeave}>Leave</button>
      <h1>{message}</h1>
    </div>
  );
};
```

- useState 함수의 인자에는 상태의 초깃값을 넣어 줍니다. 클래스형 컴포넌트에서의 state 초깃값은 객체 형태를 넣어 주어야 한다고 배웠는데, useState에서는 반드시 객체가 아니어도 상관 없습니다. 숫자일 수도, 문자열일 수도, 객체일 수도, 배열일 수도 있습니다.
- 함수를 호출하면 배열이 반환됩니다. 배열의 첫 번째 원소는 현재 상태이고, 두 번째 원소는 상태를 바꾸어 주는 함수 입니다. 이 함수를 세터(Setter) 함수라고 부릅니다.

- useState는 한 컴포넌트내에서 여러번 사용 가능합니다.

```jsx
import React, { useState } from "react";

const Say = () => {
  const [message, setMessage] = useState("");
  const onClickEnter = () => setMessage("HI");
  const onClickLeave = () => setMessage("Bye");

  const [color, setColor] = useState("black");

  return (
    <div>
      <button onClick={onClickEnter}>Enter</button>
      <button onClick={onClickLeave}>Leave</button>
      <h1 style={{ color }}>{message}</h1>
      <button style={{ color: "red" }} onClick={() => setColor("red")}>
        빨간색
      </button>
      <button style={{ color: "green" }} onClick={() => setColor("green")}>
        초록색
      </button>
    </div>
  );
};

export default Say;
```

## 3장 최종 정리

props 와 state는 둘 다 컴포넌트에서 사용하거나 렌더링할 데이터를 담고 있으므로 비슷해 보일 수 있지만, 그역할은 매우 다릅니다. props는 부모 컴포넌트가 설정하고, state는 컴포넌트 자체적으로 지닌 값으로 컴포넌트 내부에서 값을 업데이트 할 수 있습니다.

---

# 4장

## 이벤트를 사용할 때 주의 사항

1. 이벤트 이름은 카멜 표기법으로 작성합니다.
2. 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달합니다.
3. DOM 요소에만 이벤트를 설정할 수 있습니다.

- 이벤트 함수 연습

```jsx
import React, { Component } from "react";

class EventPractice extends Component {
  state = {
    username: "",
    message: "",
  };

  handleChange = (e) => {
    this.setState({
      [e.target.name]: e.target.value,
    });
  };

  handleClick = (e) => {
    alert(this.state.username + this.state.message);
  };

  render() {
    return (
      <div>
        <h1>이벤트 연습</h1>
        <input
          type="text"
          name="message"
          placeholder="아무거나 입력하세요"
          value={this.state.message}
          onChange={this.handleChange}
        />
        <input
          type="text"
          name="username"
          placeholder="이름"
          value={this.state.username}
          onChange={this.handleChange}
        />
        <button onClick={this.handleClick}>확인</button>
      </div>
    );
  }
}

export default EventPractice;
```

> 객체안에서 key를 []로 감싸면 그 안에 넣은 레퍼런스가 가리키는 실제 값이 key 값으로 사용 됩니다.

```jsx
handleChange = (e) => {
  this.setState({
    [e.target.name]: e.target.value,
  });
};
```

### 위와 같은 내용을 함수형 컴포넌트로 작성해보기

```jsx
import React, { useState } from "react";

const EventPractice = () => {
  const [form, setForm] = useState({
    username: "",
    message: "",
  });

  const { username, message } = form;

  const onChange = (e) => {
    const nextForm = {
      ...form, // 기존의 것을 복사합니다.
      [e.target.name]: e.target.value, // 원하는 값을 덮어 씌웁니다.
    };
    setForm(nextForm);
  };

  const onClick = () => {
    alert(username + " " + message);
    setForm({
      username: "",
      message: "",
    });
  };

  const onKeyPress = (e) => {
    if (e.key === "Enter") {
      onClick();
    }
  };

  return (
    <div>
      <h1>이벤트 연습</h1>
      <input
        type="text"
        name="username"
        placeholder="이름"
        value={username}
        onChange={onChange}
      />
      <input
        type="text"
        name="message"
        placeholder="아무거나 입력하세요"
        value={message}
        onKeyPress={onKeyPress}
        onChange={onChange}
      />

      <button onClick={onClick}>확인</button>
    </div>
  );
};

export default EventPractice;
```

### 4장 정리

- 리액트에서 이벤트를 다루는 것은 순수 자바스크립트 또는 jQuery를 사용한 웹 애플리케이션에서 이벤트를 다루는 것과 비슷합니다. 리액트의 장점 중 하나는 자바스크립트에 익숙하다면 쉽게 활용할 수 있다는 것입니다. 따라서 기존 HTML DOM Event를 알고 있다면 리액트의 컴포넌트 이벤트도 쉽게 다룰 수 있을 것입니다.

# 5장 ref: DOM에 이름달기

HTML에서 id를 사용하여 DOM에 이름을 다는 것처럼 리액트 프로젝트 내부에서 DOM에 이름을 다는 방법이 있습니다. 이를 ref(reference) 개념입니다.

> 리액트 컴포넌트 안에서는 id를 사용하면 안되나요?
> 리액트 컴포넌트 안에서도 id를 사용할 수는 있습니다. jsx안에서 DOM에 id를 달면 해당 DOM을 렌더링할 때 그대로 전달됩니다. 하지만 특수한 경우가 아니면 사용을 권장하지 않습니다. 예를 들어 같은 컴포넌트를 여러 번 사용한ㄷ나고 가정해 보았을 때, HTML에서 DOM의 id는 유일해야 하는데, 이런 상황에서는 중복 id를 가진 DOM이 여러 개 생기니 잘못된 사용입니다.

ref는 전역적으로 작동하지 않고 컴포넌트 내부에서만 작동하기 때문에 이런 문제가 생기지 않습니다.

>

## ref는 언제 사용해야 할까?

- DOM을 꼭 직접적으로 건드려야 할 때

DOM을 건드리지 않고 state를 사용하여 해결하는 경우

```js
class ValidationSample extends Component {
  state = {
    password: "",
    clicked: "",
    validated: "",
  };

  handleChange = (e) => {
    this.setState({
      password: e.target.value,
    });
  };

  handleButtonClick = () => {
    this.setState({
      clicked: "true",
      validated: this.state.password === "0000",
    });
  };

  render() {
    return (
      <div>
        <input
          type="password"
          value={this.state.password}
          onChange={this.handleChange}
          className={
            this.state.clicked
              ? this.state.validated
                ? "success"
                : "failure"
              : ""
          }
        />

        <button onClick={this.handleButtonClick}>검증하기</button>
      </div>
    );
  }
}
```

## DOM을 꼭 사용해야 하는 상황

- 특정 input에 포커스 주기
- 스크롤 박스 조작하기
- Canvas 요소에 그림 그리기 등

**이때는 바로 ref를 사용합니다.**

## ref 사용

ref를 사용하는 방법은 2가지가 있습니다.

- 콜백 함수를 통한 ref 설정
- createRef를 통한 ref 설정

저는 콜백 함수를 통한 ref 설정을 사용하겠습니다.

콜백 함수 사용 예시

```js
<input
  ref={(ref) => {
    this.input = ref;
  }}
/>
```

위의 Validation 예제에서는 버튼을 클릭하면 텍스트 커서가 더이상 깜빡이지 않습니다.
버튼을 클릭해도 텍스트 커서가 깜빡이도록 수정해 봅시다.

```js
  handleButtonClick = () => {
    this.setState({
      clicked: "true",
      validated: this.state.password === "0000",
    });
    this.input.focus(); // 수정
  };

  render() {
    return (
      <div>
        <input
          type="password"
          value={this.state.password}
          onChange={this.handleChange}
          className={
            this.state.clicked
              ? this.state.validated
                ? "success"
                : "failure"
              : ""
          }
          ref={(ref) => (this.input = ref)} // 수정
        />

        <button onClick={this.handleButtonClick}>검증하기</button>
      </div>
    );
  }
}
```

이런 방식으로 수정해주면 됩니다.

## 컴포넌트에서 ref 달기

이 방법은 주로 컴포넌트 내부에 있는 DOM을 컴포넌트 외부에서 사용할 때 씁니다.

1. 사용법
   `<MyComponent ref={ref} => {this.myComponent=ref}>`
   이렇게 하면 MyComponent 내부의 메서드 및 멤버 변수에도 접근할 수 있습니다.
   (ex. myComponent.handleClick, myComponent.input)

2. 컴포넌트에서 ref를 사용하는 스크롤박스 에제

- 스크롤박스 관련 메소드
  - scrollTop: 세로 스크롤바 위치
  - scrollHeight: 스크롤이 있는 박스 안의 div 높이
  - clientHeight: 스크롤이 있는 박스의 높이
  - 스크롤바를 맨 아래쪽 = scrollHeight - clientHeight

> ScrollBox.js

```js
import React, { Component } from "react";

class ScrollBox extends Component {
  scrollToBotton = () => {
    const { scrollHeight, clientHeight } = this.box;

    this.box.scrollTop = scrollHeight - clientHeight;
  };

  scrollToTop = () => {
    this.box.scrollTop = 0;
  };

  render() {
    const style = {
      border: "1px solid black",
      height: "300px",
      width: "300px",
      overflow: "auto",
      position: "relative",
    };

    const innerStyle = {
      width: "100%",
      height: "650px",
      background: "linear-gradient(white, black)",
    };

    return (
      <div
        style={style}
        ref={(ref) => {
          this.box = ref;
        }}
      >
        <div style={innerStyle} />
      </div>
    );
  }
}

export default ScrollBox;
```

> App.js

```js
class App extends Component {
  render() {
    return (
      <div>
        <ScrollBox ref={(ref) => (this.scrollBox = ref)} />
        <button onClick={() => this.scrollBox.scrollToBotton()}>
          맨 밑으로
        </button>
        <button onClick={() => this.scrollBox.scrollToTop()}>맨 위로</button>
      </div>
    );
  }
}
```

문법상 `onClick = {this.scrollBox.scrollBottom}` 같은 형식도 틀리진 않습니다. 하지만 컴포넌트가 처음 렌더링될 때는 this.scrollBox 값이 undefined이므로 this.scrollBox.scrollToBottom 값을 읽어 오는 고자ㅓㅇ에서 오류가 발생합니다. 화살표 함수 문법을 사용하여 아예 새로운 함수를 만들고 그 내부에서 this.scrollBox.scrollToBottom 메서드를 실행하면, 버튼을 누를때(이미 한번 렌더링 한 시점) this.scrollBox.scrollToBottom 값을 읽어와서 오류가 발생하지 않습니다.

## 정리

컴포넌트 내부에서 DOM에 직접 접근해야 할 때는 ref를 사용합니다.

# 6장

## 컴포넌트 반복

```js
import React, { useState } from "react";

const IterationSample = () => {
  const [names, setNames] = useState([
    { id: 1, text: "눈사람" },
    { id: 2, text: "얼음" },
    { id: 3, text: "눈" },
    { id: 4, text: "바람" },
  ]);

  const [inputText, setInputText] = useState("");
  const [nextId, setNextId] = useState(5);

  const onChange = (e) => {
    setInputText(e.target.value);
  };

  const onClick = () => {
    const nextNames = names.concat({
      id: nextId,
      text: inputText,
    });

    setNextId(nextId + 1);
    setNames(nextNames);
    setInputText("");
  };

  const onKeyPress = (e) => {
    if (e.key === "Enter") {
      onClick();
    }
  };

  const onRemove = (id) => {
    const nextNames = names.filter((name) => name.id !== id);
    setNames(nextNames);
  };

  const nameList = names.map((name) => (
    <li key={name.id} onDoubleClick={() => onRemove(name.id)}>
      {name.text}
    </li>
  ));

  return (
    <>
      <input value={inputText} onChange={onChange} onKeyPress={onKeyPress} />
      <button onClick={onClick}>추가</button>
      <ul>{nameList}</ul>
    </>
  );
};

export default IterationSample;
```

반복되는 데이터를 렌더링하는 방법을 정리해 보았습니다. 컴포넌트 배열을 렌더링할 때는 key 값 설정에 항상 주의해야 합니다. 또 key 값은 언제나 유일해야 합니다. key 값이 중복된다면 렌더링 과정에서 오류가 발생합니다.

상태 안에서 배열을 변형할 대는 배열에 직접 접근하여 수정하는 것이 아니라 concat, filter, map 등의 배열 내장 함수를 사용하여 새로운 배열을 만든 후 이를 새로운 상태로 설정해 주어야 합니다.

# 7장

## 라이프사이클 메서드

# 8장

## Hooks

- Hooks는 리액트에 새로 도입된 기능으로 함수형 컴포넌트에서도 상태 관리를 할 수 있는 useState, 렌더링 직후 작업을 설정하는 useEffect 등의 기능을 제공하여 기존의 함수형 컴포넌트에서 할 수 없었던 다양한 작업을 할 수 있게 해 줍니다.

### 1. useState

- useState는 가장 기본적인 Hook이며, 함수형 컴포넌트에서도 가변적인 상태를 지닐 수 있게 해줍니다. 함수형 컴포넌트에서 상태를 관리해야 한다면 이 Hook을 사용하면 됩니다.

```js
import React, { useState } from "react";

const Info = () => {
  const [name, setName] = useState("");
  const [nickname, setNickname] = useState("");

  const onChangeName = (e) => {
    setName(e.target.value);
  };

  const onChangeNickname = (e) => {
    setNickname(e.target.value);
  };

  return (
    <div>
      <div>
        <input value={name} onChange={onChangeName} />
        <input value={nickname} onChange={onChangeNickname} />
      </div>
      <div>이름: {name}</div>
      <div>닉네임: {nickname}</div>
    </div>
  );
};

export default Info;
```

### 2. useEffect

- useEffect는 리액트 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정할 수 있는 Hook입니다. 클래스형 컴포넌트의 componentDidMount와 componentDidUpdate를 합친 형태로 보아도 무관합니다.

위의 Info.js 예제에서 useEffect만 추가해줍니다.

```js
useEffect(() => {
  console.log("렌더링이 완료되었습니다.!");
  console.log({
    name,
    nickname,
  });
});
```

했을시 결과는

```
렌더링이 완료되었습니다.!
{name:"", nickname:""}
```

이런식으로 나옵니다. componentDidMount, componentDidUpdate와 합친형태라는 의미를 이해하시겠죠?

- 마운트될 때만 실행하고 싶을 때

```js
useEffect(() => {
  console.log("렌더링이 완료되었습니다.!");
}, []);
```

- 두 번째 파라미터로 비어 있는 배열을 넣어 주면 됩니다.

- 특정 값이 업데이트될 때만 실행하고 싶을 때

```js
useEffect(() => {
  console.log(name);
}, [name]);
```

- 두 번째 파라미터의 빈 배열 속에 특정 값을 넣어 줍니다.

### 3. 뒷정리함수(cleanup)

- 컴포넌트가 언마운트되기 전이나 업데이트되기 직전에 어떠한 작업을 수행하고 싶으면 useEffect에서 뒷정리(cleanup) 함수를 반환해 주어야 합니다.

```js
useEffect(() => {
  console.log("effect");
  console.log(name);
  return () => {
    console.log("cleanup");
    console.log(name);
  };
});
```

- useEffect 함수를 다음과 같이 수정해줍니다.
- 이름을 변경할 시 effect와 name은 바로바로 출력이 되고, 업데이트하기 직전의 값인 만약 asd를 입력한다면 clenup과 as가 출력됩니다.
- 언마운트될 때만 뒷정리 함수를 호출하고 싶다면 두 번째 파라미터에 비어있는 배열을 넣으면 됩니다.

### 4. useReducer

- useReducer는 useState보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트해 주고 싶을 때 사용하는 Hook입니다.

```js
import React, { useReducer } from "react";

const reducer = (state, action) => {
  switch (action.type) {
    case "INCREMENT":
      return { value: state.value + 1 };
    case "DECREMENT":
      return { value: state.value - 1 };
    default:
      return state;
  }
};

const Counter = () => {
  const [state, dispatch] = useReducer(reducer, { value: 0 });

  return (
    <div>
      <p>
        현재 카운터 값은 <b>{state.value}</b> 입니다.
      </p>
      <button onClick={() => dispatch({ type: "INCREMENT" })}>+1</button>
      <button onClick={() => dispatch({ type: "DECREMENT" })}>-1</button>
    </div>
  );
};

export default Counter;
```

- useReducer의 첫 번째 파라미터에는 리듀서 함수를 넣고, 두 번째 파라미터에는 해당 리듀서의 기본값을 넣어 줍니다. 이 Hook은 state 값과 dispatch 함수를 받아 옵니다. 여기서 state는 현재 가리키고 있는 상태고, dispatch는 액션을 발생시키는 함수입니다. dispatch(action)과 같은 형태입니다. useReducer의 가장 큰 장점은 컴포넌트 업데이트 로직을 컴포넌트 바깥으로 빼낼 수 있다는 것입니다.

- useReducer 인풋 상태 관리하기

```js
import React, { useReducer } from "react";

const reducer = (state, action) => {
  return {
    ...state,
    [action.name]: action.value,
  };
};

const Info = () => {
  const [state, dispatch] = useReducer(reducer, {
    name: "",
    nickname: "",
  });

  const { name, nickname } = state;
  const onChange = (e) => {
    dispatch(e.target);
  };

  return (
    <div>
      <div>
        <input name="name" value={name} onChange={onChange} />
        <input name="nickname" value={nickname} onChange={onChange} />
      </div>
      <div>이름: {name}</div>
      <div>닉네임: {nickname}</div>
    </div>
  );
};

export default Info;
```

### 5. useMemo

- useMemo를 사용하면 함수형 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있습니다. 먼저 리스트에 숫자를 추가하면 추가된 숫자들의 평균을 보여 주는 함수형 컴포넌트를 작성해 봅시다.

```js
import React, { useState } from "react";

const getAverage = (numbers) => {
  console.log("평균 값 계산중");
  if (numbers.length === 0) return 0;
  const sum = numbers.reduce((a, b) => a + b);
  return sum / numbers.length;
};

const Average = () => {
  const [list, setList] = useState([]);
  const [number, setNumber] = useState("");

  const onChange = (e) => {
    setNumber(e.target.value);
  };

  const onClick = () => {
    const nextList = list.concat(parseInt(number));
    setList(nextList);
    setNumber("");
  };
  return (
    <div>
      <input value={number} onChange={onChange} />
      <button onClick={onClick}>등록</button>
      <ul>
        {list.map((value, index) => {
          return <li key={index}>{value}</li>;
        })}
      </ul>
      평균값: {getAverage(list)}
    </div>
  );
};

export default Average;
```

이런 식으로 코드를 짰을 경우에 인풋 내용이 수정될 때도 getAverage 함수가 호출됩니다. 이 때 사용되는 것이 useMemo 입니다.

```js
const avg = useMemo(() => getAverage(list), [list]);

return (
  <div>
    <input value={number} onChange={onChange} />
    <button onClick={onClick}>등록</button>
    <ul>
      {list.map((value, index) => {
        return <li key={index}>{value}</li>;
      })}
    </ul>
    평균값: {avg}
  </div>
);
```

위 처럼 수정하면 list 배열의 내용이 바뀔 때만 함수를 호출합니다.

### 6. useCallback

- useCallback은 useMemo와 상당히 비슷한 함수입니다. 주로 렌더링 성능을 최적화해야 하는 상황에서 사용합니다.

```js
const onChange = useCallback((e) => {
  setNumber(e.target.value);
}, []); // 컴포넌트가 처음 렌더링될 때만 함수 생성

const onClick = useCallback(
  (e) => {
    const nextList = list.concat(parseInt(number));
    setList(nextList);
    setNumber("");
  },
  [number, list] // number, list가 바뀌었을 때만 함수 생성
);
```

userMemo 예제에서 onChange, onClick 함수만 수정해줍니다.
이렇게 해주지 않으면 컴포넌트가 리렌더링될 때마다 새로 만들어진 함수를 사용하게 됩니다.

### 7. useRef

- useRef Hook은 함수형 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해 줍니다. 등록 버튼을 눌렀을 때 포커스가 인풋 쪽으로 넘어가는 코드를 작성해 봅시다.

```js
import React, { useState, useMemo, useCallback, useRef } from "react";

const getAverage = (numbers) => {
  console.log("평균 값 계산중");
  if (numbers.length === 0) return 0;
  const sum = numbers.reduce((a, b) => a + b);
  return sum / numbers.length;
};

const Average = () => {
  const [list, setList] = useState([]);
  const [number, setNumber] = useState("");
  const inputEl = useRef(null); // useRef

  const onChange = useCallback((e) => {
    setNumber(e.target.value);
  }, []);

  const onClick = useCallback(
    (e) => {
      const nextList = list.concat(parseInt(number));
      setList(nextList);
      inputEl.current.focus(); // useRef
      setNumber("");
    },
    [number, list]
  );

  const avg = useMemo(() => getAverage(list), [list]);

  return (
    <div>
      <input value={number} onChange={onChange} ref={inputEl} /> {/*useRef*/}
      <button onClick={onClick}>등록</button>
      <ul>
        {list.map((value, index) => {
          return <li key={index}>{value}</li>;
        })}
      </ul>
      평균값: {avg}
    </div>
  );
};

export default Average;
```

### 정리

리액트에서 Hooks 패턴을 사용하면 클래스형 컴포넌트를 작성하지 않고도 대부분의 기능을 구현할 수 있습니다. 이러한 기능이 리액트에 릴리즈되었다고 해서 기존의 setState를 사용하는 방식이 잘못된 것은 아닙니다. 물론 useState 혹은 useReducer를 통해 구현할 수 있더라도 말이죠.
리액트 매뉴얼에 따르면, 기존의 클래스형 컴포넌트는 앞으로도 계속해서 지원될 예정입니다. 그렇기 때문에 만약 유지 보수하고 있는 프로젝트에서 클래스형 컴포넌트를 사용하고 있다면, 이를 굳이 함수형 컴포넌트와 Hooks를 사용하는 형태로 전환할 필요는 없습니다. 다만, 메뉴얼에서는 새로 작성하는 컴포넌트의 경우 함수형 컴포넌트와 Hooks를 사용할 것을 권장하고 있습니다.

## 9장 컴포넌트 스타일링

리액트에서 컴포넌트를 스타일링할 때는 다양한 방식을 사용할 수 있습니다.

- 일반 CSS: 컴포넌트를 스타일링하는 갖아 기본적인 방식입니다.
- Sass: 자주 사용되는 CSS 전처리기 중 하나로 확장된 CSS 문법을 사용하여 CSS 코드를 더욱 쉽게 작성할 수 있도록 해줍니다.
- CSS Module: 스타일 작성할 때 CSS 클래스가 다른 CSS 클래스의 이름과 절대 충돌하지 안혿록 파일마다 고유한 이름을 자동으로 생성해 주는 옵션입니다.
- styled-components: 스타일을 자바스크립트 파일에 내장시키는 방식으로 스타일을 작성함과 동시에 해당 스타일이 적용된 컴포넌트를 만들 수 있게 해 줍니다.

1. 가장 흔한 방식, 일반 CSS

프로젝트는 일반 CSS 방식으로 만들어져 있습니다. 기존의 CSS 스타일링이 딱히 불편하지 않고 새로운 기술을 배울 필요가 없다고 생각되면, 일반 CSS를 계속 사용해도 상관없습니다.
실제로도 소규모 프로젝트를 개발하고 있다면 새로운 스타일링 시스템을 적용하는 것이 불필요할수도 있습니다.

- CSS를 작성할 때 가장 중요한 점은 CSS 클래스를 중복되지 않게 만드는 것입니다. CSS 클래스가 중복되는 것을 방지하는 여러 가지 방식이 있는데, 그중 하나는 이름을 지을 때 특별한 규칙을 사용하여 짓는 것이고, 또 다른 하나는 CSS Selector를 활용하는 것입니다.

  1. 이름 짓는 규칙

  - 컴포넌트 이름-클래스 형태로 짓거나, BEM 네이밍 방식도 있습니다. BEM 네이밍은 CSS 방법론 중 하나로, 이름을 지을 때 일종의 규칙을 준수하여 해당 클래스가 어디에서 어떤 용도로 사용되는지 명확하게 작성하는 방식입니다. 예를 들어 .card_title-primary 처럼 짓습니다.

  2. CSS Selector

  - CSS Selector를 사용하면 CSS 클래스가 특정 클래스 내부에 있는 경우에만 스타일을 적용할 수 있습니다. 예를 들어 .App 안에 들어 있는 .logo에 스타일을 적용하고 싶다면

  ```css
  .App .logo {
    ...;
  }
  ```

  이러한 방식으로 작성하면 됩니다.

  태그 자체에 스타일을 적용하는 경우에는

  ```css
  .App header {
    ...;
  }
  ```

  처럼 작성하시면 됩니다.

2. Sass

Sass(Syntactically Awesome Style Sheets)(문법적으로 매우 멋진 스타일시트)는 CSS 전처리기로 복잡한 작업을 쉽게 할수 있도록 해 주고, 스타일 코드의 재활용성을 높여 주 뿐만 아니라 코드의 가독성을 높여서 유지 보수를 더욱 쉽게 해줍니다.

- Sass에서는 두 가지 확장자 .scss와 .sass를 지원합니다. 두 확장자의 차이점은 .sass 확장자는 중괄호와 세미콜론을 사용하지 않습니다. 반면 .scss 확장자는 기존 CSS를 작성하는 방식과 비교해서 문법이 크게 다르지 않습니다. 그래서 보통 .scss 문법이 더 자주 사용됩니다.

```sh
$ yarn add node-sass
```

sass를 사용하기 위해선 설치를 해주어야 합니다.

sass 사용 예제

```scss
// 변수 사용하기
$red: #fa5252;
$orange: #fd7e14;
$yellow: #fcc419;
$green: #40c057;
$blue: #339af0;
$indigo: #5c7cfa;
$violet: #7950f2;

// 믹스인 만들기(재사용되는 스타일 블록을 함수처럼 사용할 수 있음)
@mixin square($size) {
  $calculated: 32px * $size;
  width: $calculated;
  height: $calculated;
}

.SassComponent {
  display: flex;
  .box {
    background: $red;
    cursor: pointer;
    transition: all 0.3s ease-in;
    &.red {
      // .red 클래스가 .box와 함께 사용되었을 때
      background: $red;
      @include square(1);
    }
    &.orange {
      background: $orange;
      @include square(2);
    }
    &.yellow {
      background: $yellow;
      @include square(3);
    }
    &.green {
      background: $green;
      @include square(4);
    }
    &.blue {
      background: $blue;
      @include square(5);
    }
    &.indigo {
      background: $indigo;
      @include square(6);
    }
    &.violet {
      background: $violet;
      @include square(7);
    }
    &:hover {
      // .box에 마우스를 올렸을 때
      background: black;
    }
  }
}
```

- sass utils 함수 분리하기
  - 여러 파일에서 사용될 수 있는 Sass 변수 및 믹스인은 다른 파일로 따로 분리하여 작성한 뒤 필요한 곳에서 쉽게 불러와 사용할 수 있습니다.

> utils.scss

```scss
// 변수 사용하기
$red: #fa5252;
$orange: #fd7e14;
$yellow: #fcc419;
$green: #40c057;
$blue: #339af0;
$indigo: #5c7cfa;
$violet: #7950f2;

// 믹스인 만들기(재사용되는 스타일 블록을 함수처럼 사용할 수 있음)
@mixin square($size) {
  $calculated: 32px * $size;
  width: $calculated;
  height: $calculated;
}
```

3. CSS Module

...

# 10장 일정관리 웹 애플리케이션 만들기

1. TodoTemplate: 화면을 가운데에 정렬시켜 주며, 앱 타이틀을 보여 줍니다. childruen으로 내부 jsx를 props로 받아 와서 렌더링해 줍니다.
2. TodoInsert: 새로운 항목을 입력하고 추가할 수 있는 컴포넌트입니다. state를 통해 인풋의 상태를 관리합니다.
3. TodoListItem: 각 할 일 항목에 대한 정보를 보여 주는 컴포넌트입니다. todo 객체를 props로 받아 와서 상태에 따라 다른 스타일의 UI를 보여 줍니다.
4. TodoList: todos 배열을 props로 받아 온 후, 이를 배열 내장 함수 map을 사용해서 여러 개의 TodoListItem 컴포넌트로 변환하여 보여 줍니다.

> TodoTempalte.js

```js
import React from "react";
import "./TodoTemplate.scss";

const TodoTemplate = ({ children }) => {
  return (
    <div className="TodoTemplate">
      <div className="app-title">일정관리</div>
      <div className="content">{children}</div>
    </div>
  );
};

export default TodoTemplate;
```

> TodoInsert

```js
import React, { useState, useCallback } from "react";
import { MdAdd } from "react-icons/md";
import "./TodoInsert.scss";

const TodoInsert = ({ onInsert }) => {
  const [value, setValue] = useState("");

  const onChange = useCallback((e) => {
    setValue(e.target.value);
  }, []);

  const onSubmit = useCallback(
    (e) => {
      onInsert(value);
      setValue("");
      e.preventDefault();
    },
    [onInsert, value]
  );

  return (
    <form className="TodoInsert" onSubmit={onSubmit}>
      <input
        placeholder="할 일을 입력하세요"
        value={value}
        onChange={onChange}
      />
      <button type="submit">
        <MdAdd />
      </button>
    </form>
  );
};

export default TodoInsert;
```

> TodoList

```js
import React from "react";
import TodoListItem from "./TodoListItem";
import "./TodoList.scss";

const TodoList = ({ todos, onRemove, onToggle }) => {
  return (
    <div className="TodoList">
      {todos.map((todo) => (
        <TodoListItem
          todo={todo}
          key={todo.id}
          onRemove={onRemove}
          onToggle={onToggle}
        />
      ))}
    </div>
  );
};

export default TodoList;
```

> TodoListItem

```js
import React from "react";
import {
  MdCheckBoxOutlineBlank,
  MdCheckBox,
  MdRemoveCircleOutline,
} from "react-icons/md";
import cn from "classnames";
import "./TodoListItem.scss";

const TodoListItem = ({ todo, onRemove, onToggle }) => {
  const { id, text, checked } = todo;
  return (
    <div className="TodoListItem">
      <div className={cn("checkbox", { checked })} onClick={() => onToggle(id)}>
        {checked ? <MdCheckBox /> : <MdCheckBoxOutlineBlank />}
        <div className="text">{text}</div>
      </div>
      <div className="remove" onClick={() => onRemove(id)}>
        <MdRemoveCircleOutline />
      </div>
    </div>
  );
};

export default TodoListItem;
```

> App.js

```js
import React, { useState, useRef, useCallback } from "react";

import TodoTemplate from "./components/TodoTemplate";
import TodoInsert from "./components/TodoInsert";
import TodoList from "./components/TodoList";

const App = () => {
  const [todos, setTodos] = useState([
    {
      id: 1,
      text: "리액트의 기초 알아보기",
      checked: true,
    },
    {
      id: 2,
      text: "컴포넌트 스타일링 해보기",
      checked: true,
    },
    {
      id: 3,
      text: "일정 관리 앱 만들어 보기",
      checked: false,
    },
  ]);
  const nextId = useRef(4);

  const onInsert = useCallback(
    (text) => {
      const todo = {
        id: nextId.current,
        text,
        checked: false,
      };
      setTodos(todos.concat(todo));
      nextId.current = nextId.current + 1;
    },
    [todos]
  );

  const onRemove = useCallback(
    (id) => {
      setTodos(todos.filter((todo) => todo.id !== id));
    },
    [todos]
  );

  const onToggle = useCallback(
    (id) => {
      setTodos(
        todos.map((todo) =>
          todo.id === id ? { ...todo, checked: !todo.checked } : todo
        )
      );
    },
    [todos]
  );

  return (
    <TodoTemplate>
      <TodoInsert onInsert={onInsert} />
      <TodoList todos={todos} onRemove={onRemove} onToggle={onToggle} />
    </TodoTemplate>
  );
};

export default App;
```

## 정리

이 프로젝트는 소규모이기 때문에 컴포넌트 리렌더링 최적화 작업을 하지 않아도 정상적으로 작동합니다. 하지만 일정 항목이 몇 만개씩 생긴다면 새로운 항목을 추가하거나 기존 항목을 삭제 및 토글할 때 지연이 발생할 수 있습니다. 이 것을 방지하는 내용은 다음 장에서 소개하겠습니다.

# immer

```js
import React, { useState, useRef, useCallback } from "react";

const App = () => {
  const nextId = useRef(1);
  const [form, setForm] = useState({
    name: "",
    username: "",
  });
  const [data, setData] = useState({
    array: [],
    uselessValue: null,
  });

  const onChange = useCallback(
    (e) => {
      const { name, value } = e.target;
      setForm({
        ...form,
        [name]: value,
      });
    },
    [form]
  );

  const onSubmit = useCallback(
    (e) => {
      e.preventDefault();
      const info = {
        id: nextId.current,
        name: form.name,
        username: form.username,
      };

      setData({
        ...data,
        array: data.array.concat(info),
      });

      setForm({
        name: "",
        username: "",
      });

      nextId.current += 1;
    },
    [data, form.name, form.username]
  );

  const onRemove = useCallback(
    (id) => {
      setData({
        ...data,
        array: data.array.filter((info) => info.id !== id),
      });
    },
    [data]
  );

  return (
    <div>
      <form onSubmit={onSubmit}>
        <input
          name="username"
          value={form.username}
          onChange={onChange}
          placeholder="아이디"
        />
        <input
          name="name"
          value={form.name}
          onChange={onChange}
          placeholder="이름"
        />
        <button type="submit">등록</button>
      </form>
      <div>
        <ul>
          {data.array.map((info) => (
            <li key={info.id} onClick={() => onRemove(info.id)}>
              {info.username} ({info.name})
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};

export default App;
```

## 13장 SPA

SPA 는 Single Page Application의 약어 입니다. 말 그대로 한 개의 페이지로 이루어진 애플리케이션이라는 의미입니다.

다른 주소에 다른 화면을 보여 주는 것을 라우팅이라고 합니다. 리액트 라이브러리 자체에 이 기능이 내장되어 있지는 않습니다. 그 대신 브라우저의 API를 직접 사용하여 이를 관리하거나, 라이브러리를 사용하여 이 작업을 더욱 쉽게 구현할 수 있습니다.
리액트 라우팅 라이브러리는 리액트 라우터, 리치 라우터, Next.js등 여러 가지가 있습니다.
리액트 라우터는 클라이언트 사이드에서 이루어지는 라우팅을 아주 간단하게 구현할 수 있도록 해 줍니다. 더 나아가서 나중에 서버 사이드 렌더링을 할 때도 라우팅을 도와주는 컴포넌트들을 제공해 줍니다.

1. SPA의 단점
   SPA의 단점은 앱의 규모가 커지면 자바스크립트 파일이 너무 커진다는 것입니다. 하지만 코드 스플리팅을 사용하면 라우트별로 파일들을 나누어서 트래픽과 로딩 속도를 개선할 수 있습니다.

2. 리액트 라우터 사용

- yarn add react-router-dom
- 먼저 프로젝트에 리액트 라우터를 적용할 때는 src/index.js 파일에서 BrowserRouter 컴포넌트를 감싸면 됩니다.

```js
import React from "react";
import ReactDOM from "react-dom";
import { BrowserRouter } from "react-router-dom";
import "./index.css";
import App from "./App";
import * as serviceWorker from "./serviceWorker";

ReactDOM.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>,
  document.getElementById("root")
);
```

`<BrowserRouter>` 컴포넌트는 웹 애플리케이션에 HTML5의 History API를 사용하여 페이지를 새로고침하지 않고도 주소를 변경하고, 현재 주소에 관련된 정보를 props로 쉽게 조회하거나 사용할 수 있도록 해 줍니다.

- 페이지 만들기
- 먼저 Home.js , About.js를 간략하게 생성합니다 - Route를 설정해줍니다

> App.js

```js
import React from "react";
import { Route } from "react-router-dom";
import About from "./About";
import Home from "./Home";

const App = () => {
  return (
    <div>
      <Route exact path="/" component={Home} />
      <Route path="/about" component={About} />
    </div>
  );
};

export default App;
```

**exact path를 설정해주지 않는다면 /about페이지에 Home의 내용도 나오게 됩니다.**

## Link

Link 컴포넌트는 클릭하면 다른 주소로 이동시켜 주는 컴포넌트입니다. 일반 웹 애플리케이션에서는 a 태그를 사용하여 페이지를 전환합니다. 리액트 라우터를 사용할 때는 이 태그를 직접 사용하면 안 됩니다. 이 태그는 페이지를 전환하는 과정에서 페이지를 새로 불러오기 때문에 애플리케이션이 들고 있던 상태들을 모두 날려 버리게 됩니다. 렌더링된 컴포넌트들도 모두 사라지고 다시 처음부터 렌더링하게 됩니다.

Link 컴포넌트를 사용하여 페이지를 전환하면, 페이지를 새로 불러오지 않고 애플리케이션은 그대로 유지한 상태에서 페이지의 주소만 변경해 줍니다. Link 컴포넌트 자체는 a태그로 이루어져 있지만, 페이지 전환을 방지하는 기능이 내장되어 있습니다.

사용예제

```js
import React from "react";
import { Route, Link } from "react-router-dom";
import About from "./About";
import Home from "./Home";

const App = () => {
  return (
    <div>
      <ul>
        <li>
          <Link to="/">홈</Link>
        </li>
        <li>
          <Link to="/about">소개</Link>
        </li>
      </ul>
    </div>
  );
};

export default App;
```

## Route 하나에 여려 개의 path 설정하기

`<Route path={['/about', '/info']} component={About}>`

이 처럼 설정하면 됩니다.

## URL 파라미터와 쿼리

페이지 주소를 정의할 때 가끔은 유동적인 값을 전달해야 할 때도 있습니다. 이는 파라미터와 쿼리로 나눌 수 있습니다.

- 파라미터: /profile/velopert
- 쿼리: /about?details=true

일반적으로 파라미터는 특정 아이디 혹은 이름을 사용하여 조회할 때 사용하고, 쿼리는 우리가 어떤 키워드를 검색하거나 페이지에 필요한 옵션을 전달할 때 사용합니다.

### URL 파라미터

> Profile.js

```javascript
import React from "react";

const data = {
  velopert: {
    name: "김민준",
    description: "리액트를 좋아하는 개발자",
  },
  gildong: {
    name: "홍길동",
    description: "고전 소설 홍길동전의 주인공",
  },
};

const Profile = ({ match }) => {
  const { username } = match.params;
  const profile = data[username];
  if (!profile) {
    return <div>존재하지 않는 사용자입니다.</div>;
  }
  return (
    <div>
      <h3>
        {username}({profile.name})
      </h3>
      <p>{profile.description}</p>
    </div>
  );
};

export default Profile;
```

> App.js

```javascript
import React from "react";
import { Route, Link } from "react-router-dom";
import About from "./About";
import Home from "./Home";
import Profile from "./Profile";

const App = () => {
  return (
    <div>
      <ul>
        <li>
          <Link to="/">홈</Link>
        </li>
        <li>
          <Link to="/about">소개</Link>
        </li>
        <li>
          <Link to="/profile/velopert">velopert 프로필</Link>
        </li>
        <li>
          <Link to="/profile/gildong">gildong 프로필</Link>
        </li>
      </ul>
      <hr />
      <Route exact path="/" component={Home} />
      <Route path="/about" component={About} />
      <Route path="/profile/:username" component={Profile} />
    </div>
  );
};

export default App;
```

## URL 쿼리

쿼리는 location 객체에 들어 있는 search 값에서 조회할 수 있습니다. loaction 객체는 라우트로 사용된 컴포넌트에게 props로 전달되며, 웹 애플리케이션의 현재 주소에 대한 정보를 지니고 있습니다.

> location의 형태

```javascript
{
  "pathname": "/about",
  "search": "?detail=true",
  "hash": ""
}
```

위 location 객체는 http://localhost:300/about?detail=true 주소로 들어갔을 때의 값입니다. URL 쿼리를 읽을 때는 위 객체가 지닌 값 중에서 search 값을 확인해야 합니다. 이 값은 문자열 형태로 되어 있습니다. URL 쿼리는 문자열에 여러 가지 값을 설정해 줄 수 있습니다. search 값에서 특정 값을 읽어 오기 위해서는 이 문자열을 객체 형태로 변환해 주어야 합니다.

이때 qs 라이브러리를 사용합니다.
`$ yarn add qs`

> About.js

```javascript
import React from "react";
import qs from "qs";

const About = ({ location }) => {
  const query = qs.parse(location.search, {
    ignoreQueryPrefix: true, // 문자열 맨 앞의 ?를 생략합니다.
  });

  const showDetail = query.detail === "true";
  return (
    <div>
      <h1>소개</h1>
      <p>이 프로젝트는 리액트 라우터 기초를 실습해 보는 예제 프로젝트입니다.</p>
      {showDetail && <p>detail 값을 true로 설정하셨군요!</p>}
    </div>
  );
};

export default About;
```

## history

history 객체는 라우트로 사용된 컴포넌트에 match, location과 함께 전달되는 props 중 하나로, 이 객체를 통해 컴포넌트 내에 구현하는 메서드에서 라우터 API를 호출할 수 있습니다.

```javascript
import React, { Component } from "react";

class HistorySample extends Component {
  // 뒤로가기
  handleGoBack = () => {
    this.props.history.goBack();
  };

  // 홈으로 이동
  handleGoHome = () => {
    this.props.history.push("/");
  };

  componentDidMount() {
    this.unblock = this.props.history.block("정말 떠나실 건가요?");
  }

  componentWillUnmount() {
    if (this.unblock) {
      this.unblock();
    }
  }

  render() {
    return (
      <div>
        <button onClick={this.handleGoBack}>뒤로</button>
        <button onClick={this.handleGoHome}>홈ㅇ로</button>
      </div>
    );
  }
}

export default HistorySample;
```

## withRouter

withRouter 함수는 HoC(Higher-order Component) 입니다. 라우트로 사용된 컴포넌트가 아니어도 match, location, history 객체를 접근할 수 있게 해줍니다.

```javascript
import React from "react";
import { withRouter } from "react-router-dom";

const WithRouterSample = ({ location, match, history }) => {
  return (
    <div>
      <h4>location</h4>
      <textarea
        value={JSON.stringify(location, null, 2)}
        rows={7}
        readOnly={true}
      />
      <h4>match</h4>
      <textarea
        value={JSON.stringify(match, null, 2)}
        rows={7}
        readOnly={true}
      />
      <button onClick={() => history.push("/")}>홈으로</button>
    </div>
  );
};

export default withRouter(WithRouterSample);
```

## Switch

Switch 컴포넌트는 여러 Route를 감싸서 그중 일치하는 단 하나의 라우트만을 렌더링시켜 줍니다. Switch를 사용하면 모든 규칙과 일치하지 않을 때 보여 줄 Not Found 페이지도 구현할 수 있습니다.

```javascript
<Switch>
  <Route exact path="/" component={Home} />
  <Route path="/about" component={About} />
  <Route path="/profiles" component={Profiles} />
  <Route path="/history" component={HistorySample} />
  <Route
    render={({ match, location }) => (
      <div>
        <h2>이 페이지는 존재하지 않습니다.</h2>
        <p>{location.pathname}</p>
      </div>
    )}
  />
</Switch>
```

## NavLink

NavLink는 Link와 비슷합니다. 현재 경로와 Link에서 사용하는 경로가 일치하는 경우 특정 스타일 혹은 CSS 클래스를 적용할 수 있는 컴포넌트 입니다.

NavLink에서 링크가 활성화되었을 때의 스타일을 적용할 때는 activeStyle 값을, Css 클래스를 적용할 때는 activeClassName 값을 props로 넣어 주면 됩니다.

```javascript
const activeStyle = {
  background: "black",
  color: "white",
};

<NavLink activeStyle={activeStyle} to="/profiles/velopert">
  velopert 프로필
</NavLink>;
```

이런 식으로 사용하면 됩니다.

## 15. Context API

Context API는 리액트 프로젝트에서 전역적으로 사용할 데이터가 있을 때 유용한 기능입니다. 예를들면 사용자 로그인 정보, 애플리케이션 환경 설정, 테마 등 여러 종류가 있습니다. 이 기능은 리액트 관련 라이브러리에서도 많이 사용되고 있습니다. 예를 들어 리덕스, 리액트 라우터, styled-components 등의 라이브러리는 Context API를 기반으로 구현되어 있습니다.

`yarn create react-app context-tutorial`

## 16. 리덕스

리덕스는 가장 많이 사용하는 리액트 상태 관리 라이브러리입니다. 리덕스를 사용하면 컴포넌트의 상태 업데이트 관련 로직을 다른 파일로 분리시켜서 더욱 효율적으로 관리할 수 있습니다. 또한, 컴포넌트끼리 똑같은 상태를 공유해야 할 때도 여러 컴포넌트를 거치지 않고 손쉽게 상태 값을 전달하거나 업데이트할 수 있습니다.

리덕스 라이브러리는 전역 상태를 관리할 때 굉장히 효율적입니다. 단순 전역 상태 관리만 한다면 Context API를 사용하는 것만으로 충분하지만, 리덕스를 사용하면 상태를 더욱 체계적으로 관리할 수 있기 때문에 프로젝트의 규모가 클 경우에는 리덕스를 사용하는 편이 좋습니다.

## 개념 미리 정리하기

1. 액션

- 상태에 어떤 변화가 필요하면 액선이란 것이 발생합니다.

```js
{
  type: "TOGGLE_VALUE";
}
```

이러한 형식으로 이루어져 있습니다.

2. 액션 생성 함수

- 액션 생성 함수는 액션 객체를 만들어 주는 함수입니다.

```js
function addTodo(data) {
  return {
    type: "ADD_TODO",
    data,
  };
}
```

어떤 변화를 일으켜야 할 때마다 액션 객체를 만들어야 하는데 매번 액션 객체를 직접 작성하기 번거로울 수 있고, 만드는 과정에서 실수로 정보를 놓칠 수도 있습니다. 이러한 일을 방지하기 위해 이를 함수로 만들어서 관리합니다.

3. 리듀서

- 리듀서는 변화를 일으키는 함수입니다. 액션을 만들어서 발생시키면 리듀서가 현재 상태와 전달받은 액션 객체를 파라미터로 받아 옵니다. 그리고 두 값을 참고하여 새로운 상태를 만들어서 반환해 줍니다.

```js
const initialState = {
  counter: 1,
};
function reducer(state = initialState, action) {
  switch (action.type) {
    case INCREMENT:
      return {
        counter: state.counter + 1,
      };
    default:
      return state;
  }
}
```

4. 스토어
   프로젝트에 리덕스를 적용하기 위해 스토어를 만듭니다. 한 개의 프로젝트는 단 하나의 스토어만 가질 수 있습닏나. 스토어 안에는 현재 애플리케이션 상태와 리듀서가 들어가 있으며, 그 외에도 몇 가지 중요한 내장 함수를 지닙니다.
   <br>

5. 디스패치
   디스패치는 스토어의 내장 함수 중 하나입니다. 디스패치는 '액션을 발생시키는 것'이라고 이해하면 됩니다. 이 함수는 dispatch(action)과 같은 형태로 액션 객체를 파라미터로 넣어서 호출합니다.
   이 함수가 호출되면 스토어는 리듀서 함수를 실행시켜서 새로운 상태를 만들어 줍니다.
   <br>
6. 구독
   구독도 스토어의 내장 함수 중 하나입니다. subscribe 함수 안에 리스너 함수를 파라미터로 넣어서 호출해 주면, 이 리스너 함수가 액션이 디스패치되어 상태가 업데이트될 때마다 호출 됩니다.
   <br>

```js
const listener = () => {
  console.log("상태가 업데이트됨");
};
const unsubscribe = store.subscribe(listener);

unsubscribe();
```

## 리덕스 사용 예제

```js
import { createStore } from "redux";

const divToggle = document.querySelector(".toggle");
const counter = document.querySelector("h1");
const btnIncrease = document.querySelector("#increase");
const btnDecrease = document.querySelector("#decrease");

const TOGGLE_SWITCH = "TOGGLE_SWITCH";
const INCREASE = "INCREASE";
const DECREASE = "DECREASE";

const toggleSwitch = () => ({ type: TOGGLE_SWITCH });
const increase = (difference) => ({ type: INCREASE, difference });
const decrease = () => ({ type: DECREASE });

const initialState = {
  toggle: false,
  counter: 0,
};

function reducer(state = initialState, action) {
  switch (action.type) {
    case TOGGLE_SWITCH:
      return {
        ...state,
        toggle: !state.toggle,
      };
    case INCREASE:
      return {
        ...state,
        counter: state.counter + action.difference,
      };
    case DECREASE:
      return {
        ...state,
        counter: state.counter - 1,
      };
    default:
      return state;
  }
}

const store = createStore(reducer);

const render = () => {
  const state = store.getState(); // 현재 상태를 불러옵니다.
  if (state.toggle) {
    divToggle.classList.add("active");
  } else {
    divToggle.classList.remove("active");
  }

  counter.innerText = state.counter;
};

render();
store.subscribe(render);

divToggle.onclick = () => {
  store.dispatch(toggleSwitch());
};
btnIncrease.onclick = () => {
  store.dispatch(increase(1));
};
btnDecrease.onclick = () => {
  store.dispatch(decrease());
};
```

## 리덕스의 세 가지 규칙

1. 단일 스토어

- 하나의 애플리케이션 안에는 하나의 스토어가 들어 있습니다. 여러 개의 스토어를 사용하는 것이 가능은 하지만 상태 관리가 복잡해 질수 있습니다.

2. 읽기 전용 상태

- 리덕스 상태는 읽기 전용입니다. 상태를 업데이트할 때 기존의 객체는 건드리지 않고 새로운 객체를 생성해 주어야 합니다.

3. 리듀서는 순수한 함수

- 변화를 일으키는 리듀서 함수는 순수한 함수여야 합니다. 순수한 함수는 다음 조건을 만족합니다
  - 리듀서 함수는 이전 상태와 액션 객체를 파라미터로 받습니다.
  - 파라미터 외의 값에는 의존하면 안됩니다.
  - 이전 상태는 절대로 건드리지 않고, 변화를 준 새로운 상태 객체를 만들어서 반환합니다.
  - 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과 값을 반환해야 합니다.

---

## 리덕스를 사용하여 리액트 애플리케이션 상태 관리하기

## 리덕스 순서

1. 액션 타입 정하기

```js
const INCREASE = "counter/INCREASE";
const DECREASE = "counter/DECREASE";
```

2. 액션 생성 함수 만들기

```js
const INCREASE = "counter/INCREASE";
const DECREASE = "counter/DECREASE";

export const increase = () => ({ type: INCREASE });
export const decrease = () => ({ type: DECREASE });
```

3. 초기 상태 및 리듀서 함수 만들기

```js
const INCREASE = "counter/INCREASE";
const DECREASE = "counter/DECREASE";

export const increase = () => ({ type: INCREASE });
export const decrease = () => ({ type: DECREASE });

const initialState = {
  number: 0,
};

function counter(state = initialState, action) {
  switch (action.type) {
    case INCREASE:
      return {
        number: state.number + 1,
      };
    case DECREASE:
      return {
        number: state.number - 1,
      };
    default:
      return state;
  }
}

export default counter;
```

> export 와 export default의 차이점
> export는 여러 개를 내보낼 수 있지만 export default는 단 한개만 내보낼 수 있습니다.
> 불러오는 방식도 다릅니다.

```js
import counter, { increase, decrease } from "./counter";
```

## 미들웨어

리액트 웹 애플리케이션에서 API 서버를 연동할 때는 API 요청에 대한 상태도 잘 관리해야 합니다. 예를 들어 요청이 시작되었을 때는 로딩 중임을, 요청이 성공하거나 실패했을 때는 로딩이 끝났음을 명시해야 합니다. 미들웨어는 액션을 디스패치했을 때 리듀서에서 이를 처리하기에 앞서 사전에 지정된 작업들을 실행합니다. 미들웨어는 액션과 리듀서 사이의 중간자라고 볼 수 있습니다.

사용 예시

```js
import React from "react";

const loggerMiddleware = (store) => (next) => (action) => {
  console.group(action && action.type);
  console.log("이전 상태", store.getState());
  console.log("액션", action);
  next(action);
  console.log("다음 상태", store.getState());
  console.groupEnd();
};
export default loggerMiddleware;
```

```js
> index.js
const store = createStore(rootReducer, applyMiddleware(loggerMiddleware));
```

## redux-logger 사용하기

오픈 소스 커뮤니티에 이미 올라와 있는 redux-logger 을 사용해보겠습니다.

`yarn add redux-logger`

```js
import { createLogger } from "redux-logger";

const logger = createLogger();
const store = createStore(rootReducer, applyMiddleware(logger));
```

## 비동기 작업을 처리하는 미들웨어

- redux-thunk: 비동기 작업을 처리할 때 가장 많이 사용하는 미들웨어입니다. 객체가 아닌 함수 형태의 액션을 디스패치할 수 있게 해 줍니다.
- redux-saga: redux-thunk 다음으로 가장 많이 사용되는 비동기 작업 관련 미들웨어 라이브러리입니다. 특정 액션이 디스패치되었을 때 정해진 로직에 따라 다른 액션을 디스패치시키는 규칙을 작성하여 비동기 작업을 처리할 수 있게 해 줍니다.

1. redux-thunk
   redux-thunk는 리덕스를 사용하는 프로젝트에서 비동기 작업을 처리할 때 가장 기본적으로 사용하는 미들웨어입니다. 리덕스의 창시자인 댄 아브라모프가 만들었으며, 리덕스 공식 메뉴얼에서도 이 미들웨어를 사용하여 비동기 작업을 다루는 예시를 보여 줍니다.

- Thunk란?
  Thunk는 특정 작업을 나중에 할 수 있도록 미루기 위해 함수 형태로 감싼 것을 의미합니다.

## 19. 코드 스플리팅

리액트 프로젝트를 완성하여 사용자에게 제공할 때는 빌드 작업ㅇ르 거쳐서 배포해야 합니다. 빌드 작업을 통해 프로젝트에서 사용되는 자바스크립트 파일 안에서 불필요한 주석, 경고 메시지, 공백등을 제거하여 파일 크기를 최소화하기도 하고, 브라우저에서 JSX 문법이나 다른 최신 자바스크립트 문법이 원활하게 실행되도록 코드의 트랜스파일 작업도 할 수 있습니다. 만약 프로젝트 내에 이미지와 같은 정적 파일이 있땀녀 해당 파일을 위한 경로도 설정됩니다.
이 작업은 웹팩이라는 도구가 담당합니다. 웹팩에서 별도의 설정을 하지 않으면 프로젝트에서 사용 중인 모든 자바스크립트 파일이 하나의 파일로 합쳐지고, 모든 CSS 파일도 하나의 파일로 합쳐집니다.

yarn build를 하면 2로 시작하는 파일과 main으로 시작하는 파일이 있습니다. 2로 시작하는 파일에는 React, ReactDOM 등 node_moules에서 불러온 라이브러리 관련 코드가 들어있고, main으로 시작하는 파일에는 직접 프로젝트에 작성하는 App 같은 컴포넌트에 대한 코드가 들어 있습니다. 만약 App.js에 해당하는 코드를 수정한다면 main으로 시작하는 파일들의 파일명이 수정되는 것을 확인할 수 있습니다. 이렇게 파일을 분리하는 작업을 코드 스플리팅이라고 합니다.

## React.lazy와 Suspense 사용하기

```js
import React, { useState, Suspense } from "react";
import logo from "./logo.svg";
import "./App.css";
const SplitMe = React.lazy(() => import("./SplitMe"));

function App() {
  const [visible, setVisible] = useState(false);

  const onClick = () => {
    setVisible(true);
  };
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p onClick={onClick}>Hello React!</p>
        <Suspense fallback={<div>loading...</div>}>
          {visible && <SplitMe />}
        </Suspense>
      </header>
    </div>
  );
}

export default App;
```

Suspense에서 fallback props를 통해 로딩 중에 보여 줄 JSX를 지정할 수 있습니다.

## Loadable Components를 통한 코드 스플리팅

Loadable Components는 코드 스플리팅을 편하게 하도록 도와주는 서드파티 라이브러리 입니다. 이 라이브러리의 이점은 서버 사이드 렌더링을 지원한다는 것입니다. React.lazy, Suspense는 사이드 렌더링을 지원하지 않습니다. 또한, 렌더링하기 전에 필요할 때 스플리팅된 파일을 미리 불러올 수 있는 기능도 있습니다.
서버 사이드 렌더링이란 웹 서비스의 초기 로딩 속도 개선, 캐싱 및 검색 엔진 최적화를 가능하게 해 주는 기술입니다.

`yarn add @loadable/component`

```js
import React, { useState, Suspense } from "react";
import logo from "./logo.svg";
import "./App.css";
import loadable from "@loadable/component";

const SplitMe = loadable(() => import("./SplitMe"), {
  fallback: <div>loading...</div>,
}); // loadable 사용 예제

function App() {
  const [visible, setVisible] = useState(false);

  const onClick = () => {
    setVisible(true);
  };
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p onClick={onClick}>Hello React!</p>
        {visible && <SplitMe />}
      </header>
    </div>
  );
}

export default App;
```

---

## 파라미터, 쿼리 차이

일반적으로 파라미터는 처리할 작업의 카테고리를 받아 오거나, 고유 ID 혹은 이름으로 특정 데이터를 조회할 때 사용합니다. 반면, 쿼리는 옵션에 관련된 정보를 받아 옵니다. 예를 들어 여러 항목을 리스팅하는 API라면, 어떤 조건을 만족하는 항목을 보여 줄지 또는 어떤 기준으로 정렬할지를 정해야 할 때 쿼리를 사용합니다.

## 인스턴스 메서드, 스태틱 메서드

1. 인스턴스 메서드

```js
UserSchema.methods.setPassword = async function (password) {
  const hash = await bcrypt.hash(password, 10);
  this.hashedPassword = hash;
};

UserSchema.methods.checkPassword = async function (password) {
  const result = await bcrypt.compare(password, this.hashedPassword);
  return result;
};
```

인스턴스 메서드를 작성할 때는 화살표 함수가 아닌 function 키워드를 사용하여 구현해야 합니다. 함수 내부에서 this에 접근해야 하기 때문입니다. 여기서 this는 문서 인스턴스를 가리킵니다. 화살표 함수를 사용하면 this는 문서 인스턴스를 가리키지 못하게 됩니다.

2. 스태틱 메서드
```js
UserSchema.statics.findByUsername = function (username) {
  return this.findOne({ username });
};
```
스태틱 함수에서의 this는 모델을 가리킵니다. 여기서는 User를 가리킵니다.