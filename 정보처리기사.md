# 1. 요구사항 확인

## 소프트웨어 개발 방법론 2page

- 소프트웨어 생명주기

  - 소프트웨어 생명주기는 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차

- 소프트웨어 생명주기 모델 종류 : 폭 프 나 반

  - 폭포수 모델(Waterfall Model) : 소프트웨어 개발 시 각 단계를 확실히 마무리 지은 후에 다음 단계로 넘어가는 모델
    - 가장 오래된 모델
    - 고전적 생명주기 모형이라고도 함
    - 성공 사례가 많음
    - 요구사항 변경이 어려움
  - 프로토타이핑 모델 : 고객이 요구한 주요 기능을 프로토타입으로 구현하여, 고객의 피드백을 반영하여 소프트웨어를 만들어가는 모델
  - 나선형 모델 : 시스템 개발 시 위험을 최소화하기 위해 점진적으로 완벽한 시스템으로 개발해 나가는 모델
    - 절차 : 계획 및 정의 > 위험 분석 > 개발 > 고객 평가
    - 계위개고
  - 반복적 모델 : 구축대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적으로 개발하여 점증 완성시키는 모델

- 소프트웨어 개발 방법론

  - 소프트웨어 개발 전 과정에 지속적으로 적용할 수 있는 방법, 절차, 기법이다.

- 소프트웨어 개발 방법론 종류

  - 구조적 방법론
  - 정보공학 방법론
  - 객체지향 방법론
  - 컴포넌트 기반 방법론
  - 애자일 방법론
    - 절차보다 사람이 중심이 되어 변화에 유연하고 신속하게 개발할 수 있는 방법론이다
    - 개발 기간이 짧고, 폭포수 모형에 대비되는 방법론으로 개발과 함께 즉시 피드백을 받는다
    - 등장 배경 : 기존 개발 방법론의 한계를 극복하기 위해
    - 애자일 방법론의 유형
      - XP : 의사소통 개선과 즉각적 피드백으로 품질을 높이기 위한 방법론
        - 짝 프로그래밍 : 개발자 둘이서 짝으로 코딩
        - 지속적인 통합(CI) : 매일 여러 번씩 소프트웨어를 통합하고 빌드
        - 메타포어 : 공통적인 이름 체계와 시스템 서술서를 통해 고객과 개발자 간의 의사소통을 원활하게 하는 원리
        - 테스트 기반 개발(TDD) : 테스트를 먼저 수행하고, 테스트를 통과할 수 있도록 코드를 작성하는 원리
        - 리팩토링 : 프로그램의 기능을 바꾸지 않으면서 중복제거, 단순화 등을 위해 시스템을 재구성하는 원리
      - 스크럼 : 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 방법론
      - 린 : 낭비 요소를 제거하여 품질을 향상시킨 방법론

- 객체 지향 분석 방법론

  - 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 속성, 연산, 관계를 정의하여 모델링하는 기법

- 객체 지향 분석 방법론 종류
  - OOSE
    - 만든이 : 야콥슨
    - 유스케이스를 모든 모델의 근간으로 활용
  - OMT
    - 만든이 : 럼바우
    - 그래픽 표기법을 이용하여 소프트웨어 구성요소를 모델링
    - 럼바우의 객체 지향 분석 절차 : 객동기
      - 객체 모델링 : 객체들 간의 관계를 정의하여 ER 다이어그램을 만드는 과정까지의 모델링
      - 동적 모델링 : 시간의 흐름에 따라 객체들 사이의 동적인 행위를 포현하는 모델링
      - 기능 모델링 : 자료 흐름을 중심으로 철 과정 표현하는 모델링, 자료흐름도(DFD)를 활용
  - OOD
    - 만든이 : 부치
    - 다이어그램 중심으로 개발

## 비용산정, 일정관리 모형 8page

- 비용산정 모형 분류

  - 하향식 산정 방법 : 경험이 많은 전문가에게 비용 산정을 의뢰
    - 전문가판단
    - 델파이 기법 : 전문가의 경험적 지식을 통한 문제 해결 및 미레예측을 위한 기법
  - 상향식 산정 방법 : 세부적인 요구사항과 기능에 따라 필요한 비용을 계산하는 방식
    - Loc (코드라인수) : 코드 라인 수의 낙관치, 중간치, 비관치를 즉정하여 비용을 산정
    - Man Month : 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 비용 산정
    - COCOMO : 보헴이 제안한 모형, 프로그램 규모에 따라 비용을 산정
    - 푸트남 : 소프트웨어 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식
    - 기능점수(FP) : 요구 기능을 증가시키는 인자별로 가중치를 부여, 요인별 가중치를 합산하여 총 점수를 계산하여 비용 산정
      - 기능점수 = 총 기능점수 _ [0.65 + (0.1 _ 총 영향도)]

- 일정관리 모델 : 프로젝트가 기한 내 완료될 수 있도록 관리하는 모델
  - 주 공정법(CPM) : 여러 작업의 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 기법
    - 주 공정 : 시작에서 종료까지 가장 긴 시간이 걸리는 경로
  - PERT : 일의 순서를 계획적으로 정리하기 위한 기법
  - 중요 연쇄 프로젝트 관리(CCPM) : 주 공정 연쇄법으로 지원제약사항을 고려하여 일정을 작성하는 기법

## 현행 시스템 분석 16 page

- 현행 시스템 파악 절차

  - 1. 구성/기능/인터페이스 파악
  - 2. 아키텍처 및 소프트웨어 구성 파악
  - 3. 하드웨어 및 네트워크 구성 파악

- IPS : 네트워크에 대한 공격이나 침입을 실시간으로 차단, 유해 트래픽에 대한 조치를 능동적으로 처리하는 시스템
- 라우터 : OSI 3계층에서 사용하는 네트워크 장비, 네트워크 간 비용 소모가 최적화된 라우팅 경로를 설정, 설정된 경로를 따라 트래픽을 전달

- 소프트웨어 아키텍처 : 여러 가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 구성요소 간의 관계를 표현하는 시스템 구조

- 소프트웨어 아키텍처 4+1 뷰 : 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어 적인 접근 방법

  - 유스케이스 사용 : 시스템이 액터에게 제공해야하는 기능으로서 시스템 요구사항이자, 사용자 입장에서 바라본 시스템의 기능
  - 구성요소 : 유논프구배
    - 유스케이스 뷰(Usecase View)
      - 유스케이스를 도출하고 설계하며 다른 뷰를 검증하는데 사용하는 뷰
    - 논리 뷰(Logical View)
      - 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
    - 프로세스 뷰(Process View)
      - 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 비동기, 이벤트 처리 등을 포현한 뷰
    - 구현 뷰(Implementation View)
      - 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
    - 배포 뷰(Deployment View)
      - 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰

- 소프트웨어 아키텍처 패턴 유형

  - 계층화 패턴(Layered Pattern)
    - 시스템을 계층으로 구분하여 구성하는 패턴
    - 하위 모듈들은 특정한 수준의 추상화를 제공, 각 계층은 다음 상위 계층에 서비스를 제공
  - 클라이언트-서버 패턴(Client-Server Pattern)
    - 하나의 서버와 다수의 클라이언트로 구성된 패턴
  - 파이프-필터 패턴(Pipe-Filter pattern)
    - 데이터 스트림을 생성하고 처리하는 시스템에서 사용
    - 서브 시스템이 입력데이터를 받아 처리하고, 결과를 다음 서브시스템으로 넘겨주는 과정을 반복
    - 재사용성이 좋고, 추가가 쉽기 때문에 확장이 용이
  - 브로커 패턴(Broker Pattern)
    - 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 원격 서비스 실행을 통해 상호작용이 가능한 패턴
  - 모델-뷰-컨트롤러 패턴(MVC)

    - 모델 : 핵심 기능과 데이터 보관
    - 뷰 : 사용자에게 정보 표시
    - 컨트롤러 : 사용자로부터 요청을 입력받아 처리

  - 소프트웨어 아키텍처 비용 평가 모델 : SACAA

    - SAAM : 변경 용이성과 기능성에 집중, 평가가 용이하여 경험이 없는 조직에서도 활용
    - ATAM : 아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상충관계까지 평가
    - CBAM : ATAM 바탕의 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델
    - ADR : 소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델
    - ARID : 특정 부분에 대한 품질요소에 집중하는 비용 평가 모델

  - 디자인 패턴
  - 디자인 패턴 구성 요소
    - 패턴의 이름
    - 문제 및 배경
    - 솔루션
    - 사례
    - 결과
    - 샘플 코드
  - 디자인 패턴 유형

    - 목적 : 생구행
      - 생성 : 개체 인스턴스 생성에 관여, 클래스 정의, 객체 생성 방식 구조화, 캡슐화를 수행하는 패턴
      - 구조 : 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
      - 행위 : 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴
    - 범위
      - 클래스 : 컴파일 타임에 정적으로 결정
      - 객체 : 런타임에 동적으로 결정

- 디자인 패턴 종류

  - 생성 : 생빌 프로 팩앱싱
    - Builder : 복잡한 인스턴스를 조립하여 만드는 구조로, 객체를 생성하는 방법과 객체를 구현하는 방법을 분리함으로써 다른 표현 결과를 만들수 있는 패턴
    - Prototype : 처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴
    - Factory Method : 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식
    - Abstract Factory : 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
    - Singleton : 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디서든지 참조할 수 있도록 하는 패턴
  - 구조 : 구 브데 퍼플 프록 컴 어
    - Bridge : 기능 클래스 계층과 구현 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 패턴
    - Decorator : 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 패턴
    - Facade : 복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템간의 결합도를 낮추어 사용자의 측면에서 단순한 인터페이스 제공을 통해 접근성을 높일수 있는 디자인 패턴
    - Flyweight : 클래스의 경량화를 목적으로 하는 패턴
    - Proxy : 실체 객체에 대한 대리 객체, 메모리 요얄ㅇ을 아낄 수 있으며, 실체 객체를 드러나지 않게 하여 정보은닉 열할도 수행하는 패턴
    - Composite : 객체들의 관계를 트리 구조로 구성하여 부분-전체 게층으로 표현하는 패턴
    - Adapter : 기존에 생성된 클래스를 재사용할수 있도록 중간에서 맞춰주는 역할을 하는 패턴
  - 행위 : 행 미인이 템옵 스테 비커 스트 메체

    - Mediator : 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체 지향의 목표를 달성하게 해주는 패턴
    - Interpreter : 여러 형태의 언어 구문을 해석할 수 있게 만드는 패턴
    - Iterator : 내부구조를 노출하지 않고, 복잡 객체의 원소를 순차적으로 접근 가능하게 해주는 패턴
    - Template Mehtod : 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
    - Observer : 한 객체의 상태가 바뀌면 그 객체에 의존하는 객체들에게 연락이 가고 자동으로 내용이 갱신 되는 방법으로, 상호작용하는 객체 사이에서는 가능한 느슨하게 결합하는 패턴
    - State : 객체 상태를 캡슐화하여 클래스화함으로써 그것을 참조하게 하는 방식으로 유지보수의 편의성도 갖는 패턴
    - Visitor : 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하는 패턴
    - Command : 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴
    - Strategy : 알고리즘 군을 정의하고 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴
    - Memento : 클래스 설계 관점에서 객체의 정보를 젖아할 필요가 있을 때 적용하는 디자인
    - Chain of Responsibility : 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을때, 이를 동적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결한 디자인 패턴

  - 프레임워크 : 소프트웨어의 구체적인 부분에 해당하는 설게와 구현을 재사용이 가능하게끔 클래스들을 재공하는 틀

  - 분석 산출의 종류 : 현기인 아소 하네

    - 정보시스템 구성 현황
    - 정보시스템 기능 구성도
    - 인터페이스 현황
    - 현행 시스템 아키텍처 구성도
    - 소프트웨어 구성도
    - 하드웨어 구성도
    - 네트워크 구성도

  - 운영체제 : 컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있도록 해주고, 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스를 담당하는 프로그램

  - 운영체제의 종류

    - PC
      - 윈도즈 : 중/소규모 서버, 일반 PC 등 유지, 관리, 비용 장점
      - 유닉스 : 대용량 처리, 안전성 높은 서버
      - 리눅스 : 중/대규모 서버 대상, 높은 보안성
    - 모바일
      - 안드로이드 : 리눅스 운영체제 위에서 구동하며 휴대폰 전화를 비롯한 휴대용 장치를 위한 운영체제, 자바, 코틀린 언어로 프로그램을 작성
      - iOS : 스마트폰, 태블릿PC의 높은 보안성과 고성능 제공

  - 네트워크 : 컴퓨터 장치들의 노드 간 연결을 사용하여 서로에게 데이터를 교환할 수 있도록 하는 기술

  - OSI 7계층 : 아파서 티내다 피, A P S T NE DA P

    - 응용계층(Application Layer)
      - 사용자와 네트워크 간 응용서비스 연결, 데이터 생성, HTTP, FTP
    - 표현 계층 Presentation Layer
      - 데이터 형식 설정과 부호교환, 암/복호화 JPEG, MPEG
    - 세션 계층 Session Layer
      - 연결 접속 및 동기제어 SSH, TLS
    - 전송 계층 Transport Layer
      - 신뢰성 있는 통신 보장, 데이터 분할과 재조립, 흐름 제어, 오류 제어, 혼잡제어 TCP, UDP
    - Network Layer
      - 단말기 간 데이터 전송을 위한 최적화된 경로 제공 IP, ICMP
    - Data Link Layer
      - 인접 시스템 간 데이터 전송, 전송오류 제어
      - 동기화, 흐름 제어 등의 전송 기능 제어
      - 오류 검출 , 재전송 등 기능 제공
      - 이더넷
    - 물리 계층 Physical Layer
      - 0과 의 비트 정보를 회선에 보내기 위한 전기적 신호 변환

  - DBMS : 데이터베이스라는 데이터의 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용 프로그램
  - DBMS 현행 시스템 분석 시 고려 사항 : 가성 호 기구

    - 성능 측면
      - 가용성
      - 성능
      - 상호 호환성
    - 지원 측면
      - 기술 지원
      - 구축 비용

  - 미들웨어 : 분산 컴퓨팅 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어하는 소프트웨어
  - WAS : 서버 계층에서 애플리케이션이 동작할 수 있는 환경을 제공하고 안정적인 트랜잭션 처리와 관리, 다른 이기종 시스템과의 애플리케이션 연동을 지원하는 서버

  ## 요구사항 42page

  - 요구공학 : 사용자의 요구가 반영된 시스템을 개발하기 위하여 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동

  - 요구사항의 분류

    - 기능적 요구사항
      - 시스템이 제공하는 기능, 서비스에대한 요구사항
      - 기능성, 완전성, 일관성
    - 비기능적 요구사항
      - 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구
      - 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성 및 품질 관련 요구사항, 제약사항

  - 요구사항 개발 단계 구성 : 도분명확

    - 요구사항 도출 : 소프트웨어가 해결해야할 문제를 이해하고, 고객의 요구에 대한 관련 정보를 식별하고 구체적으로 표현하는 단계
      - 인터뷰 : 이해관계자와 직접 대화
      - 브레인스토밍 : 말을 꺼내기 쉬운 분위기로 만들어, 회의 참석자들이 내놓은 아이디어들을 비판없이 수용하는 회의
      - 델파이 기법 : 전문가의 경험적 지식을 통해 문제 해결, 미래 예측
      - 롤 플레잉 : 현실에 일어나는 장면을 설정하고 여러 사람이 각자 맡은 역을 연기하며 요구사항을 분석
      - 워크숍 : 단기간의 집중적인 노력을 통해 다양하고 전문적인 정보를 획득하고 공유하는 방법
      - 설문조사 : 설문지 또는 여론조사를 통해 정보를 수집
    - 요구사항 분석 : 도출된 요구사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완전성과 일관성을 확보하는 단계
    - 요구사항 명세 : 체계적으로 검토, 평가, 승인될 수 있는 문서를 작성하는 단계
    - 요구사항 확인 : 분석가가 요구사항을 이해했는지 확인하고, 일관성있고, 완전한지 검증하는 단계

    - 요구사항 명세 원리 및 검증 항목 : 명완검 일수 추개

      - 명확성
      - 완전성
      - 검증 가능성
      - 일관성
      - 수정 용이성
      - 추적 가능성
      - 개발 후 이용성

    - 비정형 명세 기법 : 사용자의 요구를 표현할 때 자연어를 기반으로 서술
    - 정형 명세 기법 : 사용자의 요구를 표현할 때 수학적인 원리와 표기법으로 서술

    - 정형 기술 검토 : 동워인
      - 동료 검토 : 2~3명이 진행하는 리뷰의 형태
      - 워크 스루 : 오류를 조기에 검출하는 데 목적, 검토 자료를 회의 전에 배포해서 사전 검토한 후 짧은 시간 동안 회의를 진행
      - 인스펙션 : 다른 전문가 또는 팀이 검사하여 오류를 찾아내는 방법
    - 상세 정형 기술 검토 : 관기 인워감
      - 관리 리뷰 : 전반적인 검토를 바탕으로 범위, 일정, 인력 등에 대한 통제 및 의사결정을 지원하는 리뷰
      - 기술 리뷰 : 정의된 계획 및 명세를 준수하고 있는지에 대한 검토를 수행하는 리뷰
      - 인스펙션
      - 워크스루
      - 감사(Audit) : 소프트웨어 제품 및 프로세스가 규제, 표준, 가이드라인, 계획, 절차를 준수하고 있는지를 독립적으로 평가하는 기법, 제 3기관이 수행

# 2. 화면 설계 2-2page

- UI : 넓은 의미에서 사용자와 시스템 사이에서 의사소통할 수 있도록 고안된 물리적, 가상의 매개체, 좁은 의미로는 사람이 접하게 되는 화면이다.
- UX(User Experience) : 사용자가 직/간접적으로 경험하면서 느끼고 생각하는 총체적 경험

- UI의 유형

  - CLI : 명령어를 텍스트로 입력하여 조작하는 사용자 인터페이스
  - GUI : 그래픽 환경을 기반으로 한 마우스나 전자펜을 이용하는 사용자 인터페이스
  - NUI : 키보드나 마우스 없이 신체 부위를 이용하는 사용자 인터페이스
  - OUI : 현실에 존재하는 모든 사물이 입출력장치로 변화할 수 있는 사용자 인터페이스

- UI 설계 원칙 : 직유학유

  - 직관성(Intuitiveness) : 누구나 쉽게 이해하고, 쉽게 사용 , 쉬운 검색, 쉬운 사용성, 일관성
  - 유효셩(Efficiency) : 정확하고 완벽하게 사용자의 목표가 달성될 수 있도록 제작, 쉬운 오류 처리 및 복구
  - 학습성(Learnability) : 초보와 숙련자 모두가 쉽게 배우고 사용할수있게 제작
  - 유연성(Flexibility) : 사용자의 요구사항을 최대한 수용하고, 실수를 방지할수 있도록 제작, 오류 예방 , 실수포용, 오류 감지

- UI 설계 지침 : 사일단결 가표접명오

  - 사용자 중심 : 사용자가 이해하기 쉽고 편하게 사용할 수 있는 환경을 제공
  - 일관성 : 버튼이나 조작방법을 사용자가 기억하기 쉽고 빠르게 습득할수있도록 설계
  - 단순성 : 조작 방법은 간단하게 작동
  - 결과 예측 가능 : 작동시킬 기능만 보고도 결과 예측이 가능해야함
  - 가시성 : 주요 기능을 메인 화면에 노출하여 쉬운 조작이 가능해야함
  - 표준화 : 디자인을 표준화하여 기능구조의 선행 학습 이후 쉽게 사용이 가능해야함
  - 접근성 : 사용자의 직무, 연령, 성별 등 다양한 게층을 수용해야 함
  - 명확성 : 사용자가 개념적으로 쉽게 인지해야함
  - 오류 발생 해결 : 사용자가 오류에 대한 상황을 정확하게 인지할 수 있어야 함

  - UI 품질 요구사항 : 기신사효유이

    - 기능성 : 실제 수행 결과와 품질 요구사항과의 차이를 분석하고, 정확하지 않은 결과가 발생할 확률과 관련하여 시스템의 동작을 관찰하기위한 기준
    - 신뢰성 : 일정한 시간 또는 작동되는 시간 동안 의도하는 기능을 수행함을 보증하는 품질 기준
    - 사용성 : 사용자와 컴퓨터 사이에 발생하는 어떠한 행위를 정확하고 쉽게 인지할 수 있는 품질 기준
    - 효율성 : 할당된 시간에 한정된 자원으로 얼마나 빨리 처리할 수 있는가에 대한 품질 기준
    - 유지보수성 : 요구사항을 개선하고 확장하는 데 있어 얼마나 용이한가에 대한 품질 기준
    - 이식성 : 다른 플랫폼에서도 많은 추가 작업 없이 얼마나 쉽게 적용이 가능한가에 대한 품질 기준

  - UI 표준 구성 : 액정 스패조

    - 전체적인 UX 원칙 : 사용자의 관점에서 업무를 효율적으로 수행할 수 있는 UX 원칙 정의
    - 정책 및 철학 : 정책 및 철학 설정
    - UI 스타일 가이드 : UI에 대한 구동 환경 및 레이아웃 등을 정의
    - UI 패턴 모델 정의 : CRUD 방식을 기반으로 데이터 입,출력 패턴 모델 정의
    - UI 표준 수립을 위한 조직 구성 : UI 팀 및 표준 개발팀을 주축으로 추진 조직 구성

  - UI 개발을 위한 주요 기법

    - 3C 분석 : Customer, Company, Competitor 고객, 자사, 경쟁사를 비교하고 분석하여 어떻게 이길 것인지 분석하는 기법
    - SWOT 분석 : Strength, Weakness, Opportunity, Threat 요인을 규정하고 이를 토대로 전략을 수립
    - 시나리오 플래닝 : 불확실성이 높은 상황 변화를 사전에 예측하고 다양한 시나리오를 설계하는 방법으로 불확싱성을 제거
    - 사용성 테스트 : 사용자가 직접 제품을 사용하면서 미리 작성된 시나리오에 맞추어 과제를 수행한후 질문
    - 워크숍 : 소집단 정도의 인원으로 연구회 및 세미나

  - 스토리보드 : UI 화면 설계를 위해서 구축하는 서비스를 위한 대부분 정보가 수록된 문서

  - UI 화면 설계 구분 : 와스프
    - 와이어프레임 : 화면구성을 협의하거나 서비스의 간략한 흐름을 공유하기 위해 화면 단위의 레이아웃을 설계
    - 스토리보드 : 서비스 구축을 위한 모든 정보가 담겨 있는 설계 산출물
    - 프로토타입 : 정적인 화면으로 설계된 와이어프레임 또는 스토리보드에 동적 효과를 적용하여 실제 구현된 것처럼 시뮬레이션할 수 있는 모형, HTML/CSS

  ## UI 설계 02-28 page

  - UML : 객체 지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어

  - UML 특징 : 가구명문

    - 가시화 언어 : 개념 모델 작성 시 오류가 적고 의사소통이 용이
    - 구축 언어 : 다양한 프로그래밍 언어로 실행 시스템의 예측 가능, UML을 소스코드로 변환하여 구축 가능
    - 명세화 언어 : 정확한 모델 제시, 완전한 모델 작성 가능
    - 문서화 언어 : 시스템에 대한 평가 및 의사소통의 문서

  - UML 구성요소

    - 사물 : 추상적인 개념으로, 주제를 나타내는 요소, 단어 관점에서 명사, 동사를 의미
    - 관계 : 사물의 의미를 확장하고 명확히 하는 요소, 형용사, 부사를 의미
    - 다이어그램 : 사물과 관계를 모아 그림으로 표현한 형태, 형식과 목적에 따라 9자리로 정의

  - UML 다이어그램

    - 구조적 다이어그램(정적 다이어그램) : 클객 컴배 복패
      - 클래스 : 클래스의 속성 및 연산과 클래스 간 정적인 관계를 표현한 다이어그램
      - 객체 : 클래스에 속한 객체들, 즉 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현한 다이어그램
      - 컴포넌트 : 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존 관계를 나타내는 다이어그램
      - 배치 : 컴포넌트 사이의 종속성을 표현하고, 물리적 요소들의 위치를 표현하는 다이어그램
      - 복합체 구조 : 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현하는 다이어그램
      - 패키지 : 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현한 다이어그램
    - 행위적 다이어그램(동적 다이어그램) : 유시커 상활타
      - 유스케이스 : 시스템이 제공하는 기능 및 그와 관련된 외부 요소를 사용자의 관점에서 표현하는 다이어그램
      - 시퀀스 : 객체 간 동적 상호 작용을 시간적 개념을 중심으로 메시지 흐름으로 표현한 다이어그램
      - 커뮤니케이션 : 동작에 참여하는 객체들이 주고 받는 메시지를 표현하고, 객체 간의 연관까지 표현하는 다이어그램
      - 상태 : 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현하는 다이어그램
      - 활동 : 시스템이 어떤 기능을 수행하는지를 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서대로 표현하는 다이어그램
      - 타이밍 : 객체 상태 변화와 시간 제약을 명시적으로 표현하는 다이어그램

  - UML의 관계 : 연의 일실 포집

    - 연관(Association) 관계
    - 의존(Dependency) 관계
    - 일반화 관계(Generalization)
    - 실체화 관계(Realization)
    - 포함 관계(Composition)
    - 집합관계(Aggregation)

  - UI 시나리오 문서의 작성 요건 : 완일이가 추수
    - 완전성
    - 일관성
    - 이해성
    - 가독성
    - 추적 용이성
    - 수정 용이성

# 3. 데이터 입출력 구현

## 데이터베이스 36page

- 데이터베이스 : 다수의 인원, 시스템 또는 프로그램이 사용할 목적으로 통합하여 관리하는 데이터의 집합이다.

- 데이터 베이스의 정의

  - 통합된 데이터 : 자료의 중복을 배제한 데이터의 모임
  - 저장된 데이터 : 저장 매체에 저장된 데이터
  - 운영 데이터 : 조직의 업무를 수행하는 데 필요한 데이터
  - 공용 데이터 : 여러 애플리케이션, 시스템들이 공동으로 사용하는 데이터

- 꽌계형 데이터베이스 관리시스템 RDBMS

  - 관계형 모델을 기반으로 하는 가장 보편화된 데이터베이스 관리시스템
  - Oracle, SQL Server, MySQL, Maria DB

- DBMS : 데이터 관리의 복잡성을 해결하는 동시에 데이터 추가, 변경, 검색, 삭제 및 백업, 복구, 보안등의 기능을 지원하는 소프트웨어

- DBMS 유형 : 키컬도그

  - Key-Value DBMS : 키 기반 Get, Put, Delete 제공, 메모리 기반에서 성능 우선 시스템 및 빅데이터 처리 기능 DBMS
    - Redis, DynamoDB
  - 컬럼 기반 데이터 저장Column Family Data Store DBMS : Key 안에 Column, Value 조합으로 된 여러개 의 필드를 갖는 DBMS
    - HBase, Cassandra
  - 문서 저장(Document Store) DBMS : Value의 데이터 타입이 Document라는 타입을 사용하는 DBMS
    - MongoDB, Couchbase
  - Graph DBMS : 시멘틱 웹과 온톨로지 분야에서 활용되는 그래프로 데이터를 표현하는 DBMS

    - Neo4j, AllegroGraph

  - DBMS 특징

    - 무결성
    - 일관성
    - 회복성
    - 보안성
    - 효율성

  - 빅데이터 : 수십 페타바이트 크기의 비정형 데이터
  - NoSQL : 데이터 저장에 고정된 테이블 스키마가 필요하지 않고 조인 연산을 사용할 수 없으며, 수평적으로 확장이 가능한 DBMS

  - 데이터 마이닝 : 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 기술
  - 데이터 마이닝의 주요 기법 : 분연 연데
    - 분류 규칙 : 과거 데이터로부터 특성을 찾아내어 분류모형을 만들어 이를 토대로 새로운 결과 값을 예측하는 기법
    - 연관 규칙 : 데이터 안에 존재하는 항목들 간의 종속관계 를 찾아내는 기법
    - 연속 규칙 : 연관 규칙에 시간 관련 정보가 포함된 형태의 기법
    - 데이터 군집화 : 대상 레코드들을 유사한 특성을 지닌 몇 개의 소그룹으로 분할하는 작업

# 6. 프로그래밍 언어 활용

- 자바는 true/false 파이썬은 True/False 대,소문자 차이
- float은 4바이트 소수점 6자리까지 표현, double은 8바이트 소수점 15자리까지 표현
- static 변수는 프로그램이 종료하기 전까지 변수가 사라지지 않고 계속 유지된다.
- 오버로딩 : 동일 이름의 메서드를 매개변수만 다르게 하여 여러 개 정의할 수 있는 기능, 파이썬에선 제공하지 않음
- 오버라이딩 : 하위 클래스에서 상위 클래스 메서드를 재정의할 수 있는 기능

- 카멜표기법 : getMathScore
- 파스칼표기법 : GetMathScore
- 스네이크표기법 : get_math_score
- 헝가리안 표기법 : 접두어에 자료형을 붙이는 표기법 ex int) nMath

- 생성자 : 일반적으로 클래스의 멤버 변수를 초기화하거나 클래스를 사용하는 데 필요한 설정이 필요한 경우 사용

- 저급 언어 : 기계까 이해할 수 있도록 만들어진 언어
  - 기계어, 어셈블리어
- 고급 언어 : 개발자가 소스 코드를 작성할 때 쉽게 이해할 수 있도록 작성된 언어
