- 단어뒤집기 : 스택활용
- bfs : 큐

# 수학 1

## 최대공약수, 최소공배수

- 최대공약수

```js
let g = 1;
for (let i = 2; i <= min(a, b); i++) {
  if (a % i === 0 && b % i === 0) {
    g = i;
  }
}

// 더 좋은 방법, 유클리드 호제법
function gcd(a, b) {
  if (b === 0) {
    return a;
  } else {
    return gcd(b, a % b);
  }
}

// 세 수의 최대 공약수 = gcd(gcd(a,b), c)
```

- 최소 공배수 : a \* b / gcd

## 소수

- 소수 알고리즘
  - 어떤 수 N이 소수인지 아닌지 판별
  - N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법

```js
function prime(n) {
  if (n < 2) {
    return false;
  }
  for (let i = 2; i * i <= n; i++) {
    if (n % i === 0) {
      return false;
    }
  }
  return true;
}
```

- 에라토스테네스의 체 : 1부터 N까지 범위 안에 들어가는 모든 소수를 구할때 사용
- 2부터 N까지 모든 수를 써놓는다
- 아직 지워지지 않은 수 중에서 갖아 작은 수를 찾고 그 수의 배수를 모두 지운다

```js
  let prime[100]; // 소수 저장
  let pn = 0; // 소수의 개수
  let check[101]; // 지워졌으면 true
  let n = 100;
  for(let i = 2; i <= n; i++) {
    if (check[i] === false) {
      prime[pn++] = i;
      for(let j = i*2; j <= n; j+=i) {
        check[j] = true;
      }
    }
  }
```

- 골드바흐의 추측

  - 2보다 큰 몯느 짝수는 두 소수의 합으로 표현 가능하다
  - 5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능하다
  - 아직 증명되지 않은 문제
  - 10^18 이하에서는 참인것이 증명되어 있다.

- 모든 소수는 6n + 1, 6n + 5의 형태로 표현이 가능하다.

# 다이나믹 프로그래밍 1

- 큰 문제를 작은 문제로 나눠서 푸는 알고리즘 (문제의 크기를 칭함)
- DP : 큰 문제를 작은 문제로 나누었을 때 중복이 가능
  - ex) 40명이 있으면 10, 30 / 15, 25 등으로 나누는 것
- 분할 정복 : D&C : 큰 문제를 작은 문제로 나누었을 때 중복 불가능

  - ex) 40명이 있으면 가운데를 기준으로 왼쪽 오른쪽으로 나누는 것

- 두 가지 속성을 만족해야 DP를 풀 수 있다.
  - Overlapping Subproblem
    - 겹치는 부분(작은)문제
    - 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다, 이러한 경우 재귀를 사용
    - 문제를 작은 문제로 쪼갤 수 있다.
  - Optimal Substructure
    - 최적부분구조
    - 문제의 정답을 작은 문제의 정답에서 구할 수 있다.
    - 예시) 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면, 대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야한다.
    - 5, 6, 7, 8, 9, 10번째 피보나치를 구하기위해서는 4번째 피보나치수는 항상 필요하다.

## 다이나믹 프로그래밍

- 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.
- 따라서, 정답을 한 번 구했으면, 정답을 어딘가에 메모해 놓는다.
- 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.
- 메모를 한다고 해서 영어로 Memorization이라고 한다.
- Memorization 예시

```js
// 기존 피보나치
function fibonacci(n) {
  if (n <= 1) {
    return n;
  } else {
    return fibonacci(n - 1) + fibonacci(n - 2);
  }
}

// memoriztion 추가
const memo = Array.from({ length: 100 }, () => 0);
function fibonacci(n) {
  if (n <= 1) {
    return n;
  } else {
    if (memo[n] > 0) {
      return memo[n];
    }
    memo[n] = fibonacci(n - 1) + fibonacci(n - 2);
    return memo[n];
  }
}
```

## 다이나믹 구현 방식에는 두 가지 방법이 있다.

- 두 가지 방법의 시간 차이는 알 수 없다.
- Top-down : 재귀
  - 큰 문제를 작은 문제로 나눈다.
  - 작은 문제를 푼다.
  - 작은 문제를 풀었으니, 이제 큰 문제를 푼다.
  - 재귀 호출을 이용해서 문제를 풀 수 있다.
- Bottom-up : 반복
  - 문제를 크기가 작은 문제부터 차례대로 푼다.
  - 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.
  - 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.
  - 반복하다 보면 가장 큰 문제를 풀 수 있다. 주로 반복문을 사용

```js
const d = Array.from({ length: 100 }, () => 0);
function fibonacci(n) {
  d[0] = 0;
  d[1] = 1;
  for (let i = 2; i <= n; i++) {
    d[i] = d[i - 1] + d[i - 2];
  }
  return d[n];
}
```
